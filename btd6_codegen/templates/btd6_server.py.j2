# Auto-generated by btd6_codegen/gen.py.

import asyncio
from typing import Any, Literal, Optional

from pydantic import BaseModel, ConfigDict, Field
from fastmcp import FastMCP
import fastmcp.server.context


# --- Pydantic Response Models ---

{% for model in models %}
class {{ model.class_name }}(BaseModel):
    """Pydantic model for {{ model.raw_name }}"""
    model_config = ConfigDict(use_attribute_docstrings=True)

{% for field in model.fields %}
    {{ field.name }}: {{ field.type_hint }} = Field(..., alias='{{ field.alias }}')
    """{{ field.description }}"""

{% endfor %}

{% endfor %}

# --- BTD6 Data Store ---

class BTD6TowerDataStore:
    """Manages BTD6 tower and hero data"""
    
    def __init__(self):
        self.towers = {
{% for tower in towers %}
            "{{ tower.id }}": Tower(
                id="{{ tower.id }}",
                name="{{ tower.name }}",
                category="{{ tower.category }}",
                cost_easy={{ tower.cost_easy }},
                cost_medium={{ tower.cost_medium }},
                cost_hard={{ tower.cost_hard }},
                cost_impoppable={{ tower.cost_impoppable }},
                description="{{ tower.description }}",
                damage={{ tower.damage }},
                pierce={{ tower.pierce }},
                attack_speed={{ tower.attack_speed }},
                range={{ tower.range }},
                projectile_speed={{ tower.projectile_speed }},
                camo_detection={{ tower.camo_detection|lower }},
                lead_popping={{ tower.lead_popping|lower }},
                frozen_popping={{ tower.frozen_popping|lower }},
                hotkey="{{ tower.hotkey or '' }}"
            ),
{% endfor %}
        }
        
        self.heroes = {
{% for hero in heroes %}
            "{{ hero.id }}": Hero(
                id="{{ hero.id }}",
                name="{{ hero.name }}",
                description="{{ hero.description }}",
                cost={{ hero.cost }},
                abilities={{ hero.abilities|tojson }}
            ),
{% endfor %}
        }
        
        self.upgrades = {
{% for tower in towers %}
{% for upgrade in tower.upgrades %}
            "{{ tower.id }}_{{ upgrade.path }}_{{ upgrade.tier }}": TowerUpgrade(
                name="{{ upgrade.name }}",
                tier={{ upgrade.tier }},
                path="{{ upgrade.path }}",
                cost_easy={{ upgrade.cost_easy }},
                cost_medium={{ upgrade.cost_medium }},
                cost_hard={{ upgrade.cost_hard }},
                cost_impoppable={{ upgrade.cost_impoppable }},
                description="{{ upgrade.description }}"
            ),
{% endfor %}
{% endfor %}
        }
    
    def get_tower(self, tower_id: str) -> Optional[Tower]:
        """Get a tower by ID"""
        return self.towers.get(tower_id)
    
    def get_hero(self, hero_id: str) -> Optional[Hero]:
        """Get a hero by ID"""
        return self.heroes.get(hero_id)
    
    def list_towers(self, category: Optional[str] = None) -> list[Tower]:
        """List all towers, optionally filtered by category"""
        towers = list(self.towers.values())
        if category:
            towers = [t for t in towers if t.category.lower() == category.lower()]
        return towers
    
    def list_heroes(self) -> list[Hero]:
        """List all heroes"""
        return list(self.heroes.values())
    
    def search_towers(self, query: str) -> list[Tower]:
        """Search towers by name or description"""
        query = query.lower()
        results = []
        for tower in self.towers.values():
            if (query in tower.name.lower() or 
                query in tower.description.lower()):
                results.append(tower)
        return results
    
    def get_upgrades_for_tower(self, tower_id: str, path: Optional[str] = None) -> list[TowerUpgrade]:
        """Get upgrades for a tower, optionally filtered by path"""
        upgrades = []
        for upgrade_id, upgrade in self.upgrades.items():
            if upgrade_id.startswith(f"{tower_id}_"):
                if path is None or upgrade.path == path:
                    upgrades.append(upgrade)
        return sorted(upgrades, key=lambda x: x.tier)


# --- FastMCP Server Setup ---

tower_data = BTD6TowerDataStore()

mcp = FastMCP(
    name="btd6-tower-stats",
    instructions="An MCP server providing comprehensive BTD6 tower statistics, upgrade paths, and detailed information scraped from community sources.",
)


# --- Tool Registration ---

@mcp.tool
async def get_tower_info(
    context: fastmcp.server.context.Context,
    tower_id: str
) -> Tower | None:
    """
    Get detailed information about a specific BTD6 tower including stats and upgrades.
    
    Args:
        tower_id: The unique identifier for the tower (e.g., 'dart_monkey', 'sniper_monkey')
    
    Returns:
        Complete tower information with stats, or None if not found
    """
    return tower_data.get_tower(tower_id)


@mcp.tool  
async def get_hero_info(
    context: fastmcp.server.context.Context,
    hero_id: str
) -> Hero | None:
    """
    Get detailed information about a specific BTD6 hero.
    
    Args:
        hero_id: The unique identifier for the hero (e.g., 'quincy', 'gwendolin')
    
    Returns:
        Complete hero information with abilities, or None if not found
    """
    return tower_data.get_hero(hero_id)


@mcp.tool
async def list_all_towers(
    context: fastmcp.server.context.Context,
    category: Optional[str] = None
) -> list[Tower]:
    """
    List all available BTD6 towers, optionally filtered by category.
    
    Args:
        category: Optional filter by tower category ('Primary', 'Military', 'Magic', 'Support')
    
    Returns:
        List of towers matching the criteria
    """
    return tower_data.list_towers(category)


@mcp.tool
async def list_all_heroes(
    context: fastmcp.server.context.Context,
) -> list[Hero]:
    """
    List all available BTD6 heroes.
    
    Returns:
        List of all heroes with their information
    """
    return tower_data.list_heroes()


@mcp.tool
async def search_towers(
    context: fastmcp.server.context.Context,
    query: str
) -> list[Tower]:
    """
    Search for BTD6 towers by name or description.
    
    Args:
        query: Search term to match against tower information
        
    Returns:
        List of towers that match the search criteria
    """
    return tower_data.search_towers(query)


@mcp.tool
async def compare_tower_costs(
    context: fastmcp.server.context.Context,
    tower_ids: list[str],
    difficulty: Literal["easy", "medium", "hard", "impoppable"] = "medium"
) -> dict[str, int]:
    """
    Compare the base costs of multiple BTD6 towers on a specific difficulty.
    
    Args:
        tower_ids: List of tower IDs to compare
        difficulty: Game difficulty level for cost comparison
        
    Returns:
        Dictionary mapping tower IDs to their costs on the specified difficulty
    """
    costs = {}
    for tower_id in tower_ids:
        tower = tower_data.get_tower(tower_id)
        if tower:
            if difficulty == "easy":
                costs[tower_id] = tower.cost_easy
            elif difficulty == "medium":
                costs[tower_id] = tower.cost_medium
            elif difficulty == "hard":
                costs[tower_id] = tower.cost_hard
            elif difficulty == "impoppable":
                costs[tower_id] = tower.cost_impoppable
    return costs


@mcp.tool
async def get_tower_upgrades(
    context: fastmcp.server.context.Context,
    tower_id: str,
    path: Optional[Literal["top", "middle", "bottom"]] = None
) -> list[TowerUpgrade]:
    """
    Get all upgrades for a specific BTD6 tower, optionally filtered by path.
    
    Args:
        tower_id: The unique identifier for the tower
        path: Optional filter for upgrade path ('top', 'middle', or 'bottom')
        
    Returns:
        List of upgrades for the specified tower and path, ordered by tier
    """
    return tower_data.get_upgrades_for_tower(tower_id, path)


@mcp.tool
async def calculate_upgrade_cost(
    context: fastmcp.server.context.Context,
    tower_id: str,
    path: Literal["top", "middle", "bottom"],
    tier: int,
    difficulty: Literal["easy", "medium", "hard", "impoppable"] = "medium"
) -> dict[str, Any]:
    """
    Calculate the total cost to upgrade a BTD6 tower to a specific tier on a specific path.
    
    Args:
        tower_id: The unique identifier for the tower
        path: The upgrade path ('top', 'middle', or 'bottom')
        tier: Target tier (1-5)
        difficulty: Game difficulty level for cost calculation
        
    Returns:
        Dictionary with base cost, upgrade costs, and total cost
    """
    tower = tower_data.get_tower(tower_id)
    if not tower:
        return {"error": "Tower not found"}
    
    # Get base cost
    if difficulty == "easy":
        base_cost = tower.cost_easy
    elif difficulty == "medium":
        base_cost = tower.cost_medium
    elif difficulty == "hard":
        base_cost = tower.cost_hard
    elif difficulty == "impoppable":
        base_cost = tower.cost_impoppable
    
    # Get upgrade costs for the path up to the specified tier
    upgrades = tower_data.get_upgrades_for_tower(tower_id, path)
    upgrades = [u for u in upgrades if u.tier <= tier]
    
    upgrade_costs = []
    total_upgrade_cost = 0
    
    for upgrade in upgrades:
        if difficulty == "easy":
            cost = upgrade.cost_easy
        elif difficulty == "medium":
            cost = upgrade.cost_medium
        elif difficulty == "hard":
            cost = upgrade.cost_hard
        elif difficulty == "impoppable":
            cost = upgrade.cost_impoppable
            
        upgrade_costs.append({"name": upgrade.name, "tier": upgrade.tier, "cost": cost})
        total_upgrade_cost += cost
    
    return {
        "tower_id": tower_id,
        "path": path,
        "target_tier": tier,
        "difficulty": difficulty,
        "base_cost": base_cost,
        "upgrades": upgrade_costs,
        "total_upgrade_cost": total_upgrade_cost,
        "total_cost": base_cost + total_upgrade_cost
    }


if __name__ == "__main__":
    print("Starting BTD6 Tower Stats MCP Server...")
    mcp.run()